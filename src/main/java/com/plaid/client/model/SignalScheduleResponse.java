/*
 * The Plaid API
 * The Plaid REST API. Please see https://plaid.com/docs/api for more details.
 *
 * The version of the OpenAPI document: 2020-09-14_1.628.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.plaid.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.plaid.client.model.SignalScheduleRecommendation;
import com.plaid.client.model.SignalWarning;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

/**
 * SignalScheduleResponse defines the response schema for &#x60;/signal/schedule&#x60;
 */
@ApiModel(description = "SignalScheduleResponse defines the response schema for `/signal/schedule`")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-21T20:52:28.374311Z[Etc/UTC]")
public class SignalScheduleResponse {
  public static final String SERIALIZED_NAME_OPTIMAL_DATE = "optimal_date";
  @SerializedName(SERIALIZED_NAME_OPTIMAL_DATE)
  private LocalDate optimalDate;

  public static final String SERIALIZED_NAME_RECOMMENDATIONS = "recommendations";
  @SerializedName(SERIALIZED_NAME_RECOMMENDATIONS)
  private List<SignalScheduleRecommendation> recommendations = new ArrayList<>();

  public static final String SERIALIZED_NAME_WARNINGS = "warnings";
  @SerializedName(SERIALIZED_NAME_WARNINGS)
  private List<SignalWarning> warnings = new ArrayList<>();

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;


  public SignalScheduleResponse optimalDate(LocalDate optimalDate) {
    
    this.optimalDate = optimalDate;
    return this;
  }

   /**
   * The recommended optimal date to submit the debit entry, formatted in ISO 8601 \&quot;YYYY-MM-DD\&quot; (e.g., \&quot;2024-03-30\&quot;). The &#x60;optimal_date&#x60; is derived from the date with rank &#x3D; 1 in the following recommendations array.  NOTE: The &#x60;default_payment_method&#x60; field specified in the request will affect the recommendation, since we&#39;re accounting for debit settlement time.  The debit scheduling evaluation starts from the day the /signal/schedule request is submitted (Day 0) or the next banking day if the submission day is not a banking day, and extends through the following five banking days (Day 1 to Day 5). If no date within this period is considered likely to result in a successful debit attempt, &#x60;null&#x60; will be returned for the &#x60;optimal_date&#x60;.
   * @return optimalDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The recommended optimal date to submit the debit entry, formatted in ISO 8601 \"YYYY-MM-DD\" (e.g., \"2024-03-30\"). The `optimal_date` is derived from the date with rank = 1 in the following recommendations array.  NOTE: The `default_payment_method` field specified in the request will affect the recommendation, since we're accounting for debit settlement time.  The debit scheduling evaluation starts from the day the /signal/schedule request is submitted (Day 0) or the next banking day if the submission day is not a banking day, and extends through the following five banking days (Day 1 to Day 5). If no date within this period is considered likely to result in a successful debit attempt, `null` will be returned for the `optimal_date`.")

  public LocalDate getOptimalDate() {
    return optimalDate;
  }


  public void setOptimalDate(LocalDate optimalDate) {
    this.optimalDate = optimalDate;
  }


  public SignalScheduleResponse recommendations(List<SignalScheduleRecommendation> recommendations) {
    
    this.recommendations = recommendations;
    return this;
  }

  public SignalScheduleResponse addRecommendationsItem(SignalScheduleRecommendation recommendationsItem) {
    this.recommendations.add(recommendationsItem);
    return this;
  }

   /**
   * This array provides a date-by-date evaluation of debit submission recommendations within the five banking day evaluation period. Each object in the array represents a retry recommendation for a specific date.
   * @return recommendations
  **/
  @ApiModelProperty(required = true, value = "This array provides a date-by-date evaluation of debit submission recommendations within the five banking day evaluation period. Each object in the array represents a retry recommendation for a specific date.")

  public List<SignalScheduleRecommendation> getRecommendations() {
    return recommendations;
  }


  public void setRecommendations(List<SignalScheduleRecommendation> recommendations) {
    this.recommendations = recommendations;
  }


  public SignalScheduleResponse warnings(List<SignalWarning> warnings) {
    
    this.warnings = warnings;
    return this;
  }

  public SignalScheduleResponse addWarningsItem(SignalWarning warningsItem) {
    this.warnings.add(warningsItem);
    return this;
  }

   /**
   * If bank information was not available to be used in the Signal model, this array contains warnings describing why bank data is missing. If you want to receive an API error instead of Signal scores in the case of missing bank data, file a support ticket or contact your Plaid account manager.
   * @return warnings
  **/
  @ApiModelProperty(required = true, value = "If bank information was not available to be used in the Signal model, this array contains warnings describing why bank data is missing. If you want to receive an API error instead of Signal scores in the case of missing bank data, file a support ticket or contact your Plaid account manager.")

  public List<SignalWarning> getWarnings() {
    return warnings;
  }


  public void setWarnings(List<SignalWarning> warnings) {
    this.warnings = warnings;
  }


  public SignalScheduleResponse requestId(String requestId) {
    
    this.requestId = requestId;
    return this;
  }

   /**
   * A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
   * @return requestId
  **/
  @ApiModelProperty(required = true, value = "A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.")

  public String getRequestId() {
    return requestId;
  }


  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SignalScheduleResponse signalScheduleResponse = (SignalScheduleResponse) o;
    return Objects.equals(this.optimalDate, signalScheduleResponse.optimalDate) &&
        Objects.equals(this.recommendations, signalScheduleResponse.recommendations) &&
        Objects.equals(this.warnings, signalScheduleResponse.warnings) &&
        Objects.equals(this.requestId, signalScheduleResponse.requestId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(optimalDate, recommendations, warnings, requestId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SignalScheduleResponse {\n");
    sb.append("    optimalDate: ").append(toIndentedString(optimalDate)).append("\n");
    sb.append("    recommendations: ").append(toIndentedString(recommendations)).append("\n");
    sb.append("    warnings: ").append(toIndentedString(warnings)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

